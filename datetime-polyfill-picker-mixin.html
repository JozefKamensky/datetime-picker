<link rel="import" href="../input-picker-pattern/input-picker-pattern.html">
<link rel="import" href="../input-picker-pattern/input-shared-style.html">
<link rel="import" href="../input-picker-pattern/dropdown-style.html">

<script>
  /**
   * mixin to extend an element with a test for an expected input type and implement a polyfill, when wanted or needed
   *
   * @appliesMixin InputPickerPattern
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimePolyfillPickerMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends InputPickerPattern(superClass) {  // eslint-disable-line no-undef
      /**
       * template for native input element
       * @type {string}
       */
      static get _nativeInputTemplate() {
        return `
          <input class="native" type="${this.expectedNativeInputType}" hidden$="[[!native]]" disabled$="[[disabled]]" min="[[min]]" max="[[max]]" value="{{${this.nativeInputBinding || this.expectedNativeInputType}::input}}" step="1">
        `;
      }

      static get replacementInputTemplate() {
        return `
          <${this.nativeInputBinding}-input class="replacement" locale="[[locale]]" hour12=[[hour12]] clamp="[[clamp]]" value="{{confirmedValue}}" with-timezone="{{withTimezone}}" timezone-offset="[[timezoneOffset]]" min="[[min]]" max="[[max]]"></${this.nativeInputBinding}-input>
        `;
      }

      static get nativeInputBinding() {
        return 'datetime';
      }

      static get customStyleToInclude() {
        return `input-shared-style dropdown-style`;
      }

      /**
       * custom style content
       * @type {string}
       */
      static get customStyleContent() {
        return `
          ${super.customStyleContent || ''}
          #polyfill {
            @apply --input-style;
            padding: 0;
          }
          #polyfill > * {
            --input-color: currentColor;
            --input-background: transparent;
          }
          #polyfill:hover,
          #polyfill:focus {
            color: var(--input-focus-color);
            background: var(--input-focus-background);
            @apply --input-focus;
          }
          #picker {
            @apply --input-picker;
            padding: 0;
          }
          #picker #buttons {
            background-color: var(--input-background);
            color: var(--input-color);
          }
        `;
      }

      static get properties() {
        return {
          confirmedDate: {
            type: String,
            notify: true
          },

          confirmedTime: {
            type: String,
            notify: true
          },

          confirmedDatetime: {
            type: String,
            notify: true
          },

          confirmedValue: {
            type: Number,
            notify: true
          }
        };
      }

      static get observers() {
        return [
          '_confirmedDateTimeChanged(confirmedDate, confirmedTime)',
          '_confirmedDatetimeChanged(confirmedDatetime)',
          '_confirmedValueChanged(confirmedValue)'
        ];
      }

      connectedCallback() {
        super.connectedCallback();
      }

      /**
       * key press event handler
       * @param  {[type]} e Event
       */
      _checkKeycode(e) {
        if (!e || (!this._hasNative || this.native)) {
          return;
        }
        if (this.opened) {
          super._checkKeycode(e);
        } else {
          this.open();
        }
      }

      _setDate(d) {
        super._setDate(d);
        if (this.autoConfirm || (!this._hasNative || this.native)) {
          this._setConfirmedValues();
        }
      }

      _timezoneOffsetChanged(timezoneOffset, o) {
        super._timezoneOffsetChanged(timezoneOffset, o);
        if (timezoneOffset.match(this._regexpTimezone)) {
          this.confirm();
        }
      }

      confirm() {
        super.confirm();
        this._setConfirmedValues();
      }

      cancel() {
        this._resetValues();
        super.cancel();
      }

      _confirmedDateTimeChanged(confirmedDate, confirmedTime) {
        if (!(confirmedDate && confirmedTime)) {
          return;
        }
        this._datetimeChanged(confirmedDate + 'T' + confirmedTime);
        setTimeout(() => {
          this._setConfirmedValues();
        }, 0);
      }

      _confirmedDatetimeChanged(confirmedDatetime) {
        if (!confirmedDatetime) {
          return;
        }
        this._datetimeChanged(confirmedDatetime);
        setTimeout(() => {
          this._setConfirmedValues();
        }, 0);
      }

      _confirmedValueChanged(confirmedValue) {
        if (isNaN(confirmedValue)) {
          return;
        }
        this._valueChanged(confirmedValue);
        setTimeout(() => {
          this._setConfirmedValues();
        }, 0);
      }

      _setConfirmedValues() {
        if (isNaN(this.value)) {
          return;
        }
        
        let d = this._clamp(new Date(this.value), this.clamp);
        if (this.min && this._checkMin(d) === false) {
          d = this._fromDatetime(this.min);
        } else if (this.max && this._checkMax(d) === false) {
          d = this._fromDatetime(this.max);
        }
        let toSet = {};
        const value = +d;
        // transform the date
        d.setMinutes(d.getMinutes() - this._offsetMinutes + d.getTimezoneOffset());
        const date = this._toDate(d),
          time = this._toTime(d),
          datetime = date + 'T' + time;

        if (time !== undefined && this.confirmedTime !== time) {
          toSet.confirmedTime = time;
        }
        if (date !== undefined && this.confirmedDate !== date) {
          toSet.confirmedDate = date;
        }
        if (datetime !== undefined && this.confirmedDatetime !== datetime) {
          toSet.confirmedDatetime = datetime;
        }
        if (value !== undefined && this.confirmedValue !== value) {
          toSet.confirmedValue = value;
        }


        console.log(toSet);
        this.setProperties(toSet)
      }

      _resetValues() {
        let toSet = {};
        if (this.confirmedTime !== undefined && this.confirmedTime !== this.time) {
          toSet.time = this.confirmedTime;
        }
        if (this.confirmedDate !== undefined && this.confirmedDate !== this.date) {
          toSet.date = this.confirmedDate;
        }
        if (this.confirmedDatetime !== undefined && this.confirmedDatetime !== this.datetime) {
          toSet.datetime = this.confirmedDatetime;
        }
        if (this.confirmedValue !== undefined && this.confirmedValue !== this.value) {
          toSet.value = this.confirmedValue;
        }
        this.setProperties(toSet)
      }
    }
  }
</script>
