<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../number-input/integer-input.html">

<link rel="import" href="datetime-picker-mixin.html">

<script>
  /**
   * Mixin for calendar-element
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const CalendarElementPattern = (superClass) => class extends superClass { // eslint-disable-line no-unused-vars

    static get customStyleContent() {
      return `
        ${super.customStyleContent}
        #calendar {
          display: -ms-inline-flexbox;
          display: -webkit-inline-flex;
          display: inline-flex;
          flex-direction: column;
          background: var(--input-background);
          color: var(--input-color);
          padding: 4px;
          @apply --input-picker;
          @apply --calendar-element;
        }
        #calendar #top {
          display: -ms-inline-flexbox;
          display: -webkit-inline-flex;
          display: inline-flex;
          flex-direction: row;
          align-items: center;
        }
        #calendar .view {
          display: -ms-inline-flexbox;
          display: -webkit-inline-flex;
          display: inline-flex;
          flex-direction: row;
          align-items: center;
          flex-grow: 1;
          padding: 0 4px;
          cursor: pointer;
        }
        #calendar .view > * {
          flex: 0 0 auto;
        }
        #calendar #monthSelector {
          -moz-appearance: none;
          -webkit-appearance: none;
          appearance: none;
          text-indent: 0.01px;
          text-overflow: '';
          text-align-last: center;
          flex: 1 0 auto;
          font-family: inherit;
          font-size: inherit;
          font-weight: inherit;
          color: currentColor;
          background: transparent;
          @apply --input-style;
        }
        #calendar #monthSelector:hover,
        #calendar #monthSelector:focus {
          color: var(--input-focus-color);
          background: var(--input-focus-background);
        }
        #calendar #monthSelector option {
          color: var(--input-color);
          background: var(--input-background);
        }
        #calendar #year {
          font-weight: bold;
        }
        #calendar #content {
          display: table;
        }
        #calendar #header {
          display: table-header-group;
          cursor: default;
        }
        #calendar #dates {
          display: table-row-group;
        }
        #calendar #dates:focus {
          outline: none;
        }
        #calendar .week {
          display: table-row;
        }
        #calendar .day {
          display: table-cell;
          position: relative;
          width: calc(100% / 7);
          -webkit-background-clip: padding-box;
          background-clip: padding-box;
          font-size: 0.8em;
          text-align: center;
          white-space: nowrap;
          border-radius: 0.3em;
          @apply --calendar-date-cell;
        }
        #calendar .day::before {
          content: '';
          display: block;
          width: var(--calendar-date-width, 2.8em);
          margin-top: 100%;
        }
        #calendar .day::after {
          content: attr(data-day);
          position: absolute;
          top: 50%;
          right: 50%;
          transform: translate(50%, -50%);
        }
        #calendar #dates .day {
          cursor: pointer;
          will-change: background;
          transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1), box-shadow 150ms cubic-bezier(0.6, 1, 0.2, 1);
        }
        #calendar #dates .day:hover {
          box-shadow: inset 0 0 1px currentColor;
          @apply --calendar-date-cell-hovered;
        }
        #calendar #dates .day.current {
          box-shadow: inset 0 0 1px 1px currentColor;
        }
        #calendar #dates .day.selected {
          background: var(--input-focus-background);
          color: var(--input-focus-color);
          box-shadow: none;
        }
        #calendar #dates:focus .day.selected {
          box-shadow: inset 0 0 1px 1px currentColor;
        }
        #calendar #dates .day.recent {
          box-shadow: inset 0 0 1px 1px var(--input-focus-background);
        }
        #calendar #dates .day.notinmonth {
          opacity: 0.5;
        }
        #calendar #dates .day.outofrange {
          opacity: 0.15;
          font-style: italic;
          pointer-events: none;
        }
      `;
    }

    static get calendarTemplate() {
      return `
        ${super.contentTemplate || ''}
        <div id="calendar">
          <div id="top">
            <button class="icon switch" prop="month" step="-1">${this._iconStepLeft}</button>
            <div class="view">
              <select id="monthSelector" hidden$="[[_hideMonth]]" tabindex="0" style="order:[[_orderDate.month]];" value="{{month::change}}"></select>
              <integer-input id="year" style="order:[[_orderDate.year]];" pad-length="4" placeholder="- - - -" value="{{year}}"></integer-input>
            </div>
            <button class="icon switch" prop="month" step="1">${this._iconStepRight}</button>
          </div>

          <div id="content" hidden$="[[_hideDay]]">
            <div id="header">
              <div id="caption" class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
            </div>

            <div id="dates" tabindex="0" on-mousedown="_onClickDay" on-mousemove="_onMouseMoveDay" on-focus="_addKeylistenerForDates" on-blur="_removeKeylistenerForDates">
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
              <div class="week">
                <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div> <div class="day"></div>
              </div>
            </div>
          </div>
        </div>
      `
    }

    static get properties() {
      return {
        /**
         * Clamp datetime to a property
         * possible values: 'month', 'day', 'hours'
         */
        clamp: {
          type: String,
          value: 'hours'
        },

        /**
         * Current hovered day node
         * to access: bind the attribute ('current-hovered-day') and get its '.dataset.date'- property represents the DateString
         */
        currentSelectedDayNode: {
          type: Node,
          notify: true
        },

        /**
         * Node of the last selected day (warning: if view changes )
         * to access: bind the attribute ('current-hovered-day') and get its '.dataset.date'- property represents the DateString
         */
        currentHoveredDayNode: {
          type: Node,
          notify: true
        },

        _hideMonth: {
          type: Boolean,
          computed: '_ifClamped(clamp, "month")'
        },

        _hideDay: {
          type: Boolean,
          computed: '_ifClamped(clamp, "day")'
        },

        _regexpDate: {
          type: RegExp,
          value: /(-?\d+)-(\d\d)-(\d\d)/
        }
      }
    }

    connectedCallback() {
      super.connectedCallback();
      let d;
      if (this.default) {
        d = new Date(this.default);
      }
      if (isNaN(d)) {
        d = new Date();
      }
      this.$.year.startAt = d.getFullYear();
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this._removeKeylistenerForDates();
    }

    _dateTimeChanged(date, time) {
      super._dateTimeChanged(date, time);
      this.renderCalendar(this.year, this.month, this.day, this.date || date);
    }

    _onClickDay(e) {
      this._onMouseMoveDay(e);
      if (this.currentHoveredDayNode) {
        this.currentSelectedDayNode = this.currentHoveredDayNode;
        const match = this._regexpDate.exec(this.currentSelectedDayNode.dataset.date);
        if (!match) {
          this._dayClicked = false;
          return;
        }
        setTimeout(() => {
          this.setProperties({
            year: +match[1],
            month: +match[2],
            day: +match[3],
            date: this.currentSelectedDayNode.dataset.date
          })
        }, 0);
      }
      if (this._dayClicked === true) {
        this._onDblClickDay(this.currentSelectedDayNode.dataset.date);
        this._dayClicked = false;
        return;
      }
      this._dayClicked = true;
      setTimeout(() => {
        this._dayClicked = false;
      }, 250);
    }

    _onDblClickDay(date) {
      this.renderCalendar(this.year, this.month, this.day, date);
    }

    _onMouseMoveDay(e) {
      if (e) {
        const paths = e.path || [e.target];
        for (let i = 0; i < paths.length; i++) {
          if (paths[i].dataset && paths[i].dataset.date) {
            if (this.currentHoveredDayNode) {
              this.currentHoveredDayNode.classList.remove('hovered');
            }
            paths[i].classList.add('hovered');
            this.currentHoveredDayNode = paths[i];
            break;
          }
        }
      }
    }

    _localeChanged(locale) {
      if (!locale) {
        this.locale = window.navigator.language;
        return;
      }
      super._localeChanged(locale);

      while (this.$.monthSelector.hasChildNodes()) {
        this.$.monthSelector.removeChild(this.$.monthSelector.lastChild);
      }
      for (let i = 1; i <= 12; i++) {
        let option = document.createElement('option');
        option.textContent = (new Date(1970, i - 1, 15)).toLocaleDateString(locale, {
          month: 'long'
        });
        option.value = i;
        this.$.monthSelector.appendChild(option);
      }

      if (this.month !== undefined) {
        this.$.monthSelector.selectedIndex = this.month - 1;
      }

      // set weekday titles
      for (let i = 0; i < 7; i++) {
        let d = new Date(0, 0, i);
        let weekday = (d.getDay() - 1 + 7) % 7;
        if (this.$.caption.children[weekday]) {
          this.$.caption.children[weekday].dataset.day = d.toLocaleDateString(locale, {
            weekday: 'short'
          });
        }
      }
    }

    /**
     * renderCalendars the current view (manually).
     * @param {number} year The year of the date of the current view.
     * @param {number} month The month of the date of the current view.
     * @param {number} day The day of the date of the current view.
     * @param {number} date The current selected date.
     */
    renderCalendar(year, month, day, date) {
      if (year === undefined || month === undefined || day === undefined) return;
      const d = new Date(year, +month - 1, day);

      if (isNaN(+d)) {
        return;
      }

      if (date === undefined) {
        date = this.confirmedDate || this.date;
      }
      if (this._ifClamped(this.clamp, 'day')) {
        this.date = this._toDate(d);
        return;
      }

      year = d.getFullYear();
      month = d.getMonth();
      const current = new Date();

      const firstDayOfMonth = new Date(year, month, 0),
        currentDay = this._dayDiff(new Date(current.getFullYear(), current.getMonth(), current.getDate()), firstDayOfMonth),
        selectedDay = this._dayDiff(d, firstDayOfMonth);

      let recentDay, min, max;

      recentDay = this._dayDiff(new Date(date), firstDayOfMonth);

      if (this.min) {
        let minDate = new Date(this.min);
        min = this._dayDiff(new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate()), firstDayOfMonth);
      }
      if (this.max) {
        let maxDate = new Date(this.max);
        max = this._dayDiff(new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate()), firstDayOfMonth);
      }

      const prevmonthlength = +new Date(year, month, 0).getDate();
      const thismonthlength = +new Date(year, month + 1, 0).getDate();
      const firstWeekDay = +new Date(year, month, 1).getDay() - 1; // Monday is first day
      let selectedDayInView;

      let counter = -(7 + firstWeekDay) % 7 + 1;
      for (let i = 0; i < this.$.dates.children.length; i++) {
        for (let j = 0; j < this.$.dates.children[i].children.length; j++) {
          // Day Numbers
          if (counter <= 0) {
            this.$.dates.children[i].children[j].classList.add('notinmonth');
            this.$.dates.children[i].children[j].dataset.day = prevmonthlength + counter;
          } else if (counter > thismonthlength) {
            this.$.dates.children[i].children[j].classList.add('notinmonth');
            this.$.dates.children[i].children[j].dataset.day = counter - thismonthlength;
          } else {
            this.$.dates.children[i].children[j].classList.remove('notinmonth');
            this.$.dates.children[i].children[j].dataset.day = counter;
          }
          // Day is Selected Day
          if (counter === selectedDay) {
            this.$.dates.children[i].children[j].classList.add('selected');
            this.currentSelectedDayNode = this.$.dates.children[i].children[j];
            selectedDayInView = true;
          } else {
            this.$.dates.children[i].children[j].classList.remove('selected');
          }
          // Day is Recent Selected Day
          if (counter === recentDay) {
            this.$.dates.children[i].children[j].classList.add('recent');
          } else {
            this.$.dates.children[i].children[j].classList.remove('recent');
          }
          // Day is Current Day
          if (counter === currentDay) {
            this.$.dates.children[i].children[j].classList.add('current');
          } else {
            this.$.dates.children[i].children[j].classList.remove('current');
          }
          // Day is below Min or above Max
          if ((min !== undefined && counter < min) || (max !== undefined && counter > max)) {
            this.$.dates.children[i].children[j].classList.add('outofrange');
          } else {
            this.$.dates.children[i].children[j].classList.remove('outofrange');
          }
          this.$.dates.children[i].children[j].dataset.date = this._toDate(new Date(year, month, counter));
          counter++;
        }
      }

      if (!selectedDayInView) {
        this.currentSelectedDayNode = null;
      }
      // fix for initial view
      this.$.monthSelector.selectedIndex = this.month - 1;
    }

    _dayDiff(end, start) {
      return Math.round((end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6E4) / 865E5);
    }

    _minChanged(min) {
      super._minChanged(min);
      this.renderCalendar(this.year, this.month, this.day, this.date);
    }

    _maxChanged(max) {
      super._maxChanged(max);
      this.renderCalendar(this.year, this.month, this.day, this.date);
    }

    _addKeylistenerForDates() {
      this.$.dates.addEventListener('keydown', this._checkKeycodeForDates.bind(this), false);
    }

    _removeKeylistenerForDates() {
      this.$.dates.removeEventListener('keydown', this._checkKeycodeForDates.bind(this), false);
    }

    /**
     * key press event handler on dates area
     * @param  {[type]} e Event
     */
    _checkKeycodeForDates(e) {
      if (e && e.keyCode) {
        switch (e.keyCode) {
          case 37: // left
            this._incremProp('day', -1);
            e.preventDefault();
            e.stopPropagation();
            return;
          case 39: // right
            this._incremProp('day', 1);
            e.preventDefault();
            e.stopPropagation();
            return;
          case 38: // up
            this._incremProp('month', 1);
            e.preventDefault();
            e.stopPropagation();
            return;
          case 40: // down
            this._incremProp('month', -1);
            e.preventDefault();
            e.stopPropagation();
            return;
        }
      }
    }

  }
</script>

<dom-module id="calendar-element">
  <script>
  /**
  * `<calendar-element>` adds a calendar to your page using Polymer.
  *
  * If you like to connect it to an input, try it like:
  *
  *   ```html
  *     <input type="date" value="{{date::input}}">
  *
  *     <calendar-element date="{{date}}"></calendar-element>
  *   ```
  *
  * For example if you clamp on `hours`, you can round `datetime` and `value` to `00:00:00`. If you set `clamp="day"` you hide the day-selection.
  *
  * The following custom properties and mixins are also available for styling:
  *
  * Custom property | Description | Default
  * ----------------|-------------|----------
  * `--input-color` | text-color of the element | `#dadada`
  * `--input-background` | text-color of the element | `#2b2b2b`
  * `--input-focus-color` | color of the focussed or hovered inputs and icons | `#f5f5f5`
  * `--input-focus-background` | background of the focussed or hovered inputs and icons | `--primary-color, #394FE8`
  * `--input-style` | Mixin applied to the inputs | { border-radius: 3px; padding: 0.2em 0.1em; border: none; outline: none; text-align: center; color: inherit; cursor: pointer; background: transparent; box-sizing: content-box; transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1);`
  * `--input-focus` | Mixin applied to the focussed or hovered inputs | {}`
  * `--input-icon` | Mixin applied to the icons | `{border-radius: 2px; padding: 8px; height: 16px; width: 16px; background: transparent; transition: background 150ms cubic-bezier(0.6, 1, 0.2, 1); cursor: pointer; fill: currentColor; }`
  * `--input-picker` | Mixin applied to the element | `{box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 1px 8px 0 rgba(0, 0, 0, 0.12), 0 3px 3px -2px rgba(0, 0, 0, 0.4); border-radius: 4px;}`
  * `--calendar-element` | Mixin applied to the calender | `{}`
  *
  * @customElement
  * @polymer
  *
  * @appliesMixin CalendarElementPattern
  * @appliesMixin DatetimePickerMixin
  *
  * @demo demo/date-picker.html date elements
  **/
    class CalendarElement extends CalendarElementPattern(DatetimePickerMixin(Polymer.Element)) { // eslint-disable-line no-undef

      static get is() {
        return 'calendar-element';
      }

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.calendarTemplate}
        `
      }

      _dateTimeChanged(date, time) {
        if (this.__updatingTimezoneOffset) {
          return;
        }
        if (date === undefined) {
          if (this.default !== undefined) {
            this._setDate(new Date(this.default));
          } else {
            this._resetDate();
          }
          return;
        }
        this.datetime = date + 'T' + (time || '00:00') + (this.timezone || 'Z');

        this.renderCalendar(this.year, this.month, this.day, this.confirmedDate || this.date || date);
      }

    }
    window.customElements.define(CalendarElement.is, CalendarElement);
  </script>
</dom-module>
